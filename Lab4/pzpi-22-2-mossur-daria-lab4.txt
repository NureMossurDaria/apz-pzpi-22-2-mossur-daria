Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Лабораторна робота №4
з дисципліни: «Архітектура програмного забезпечення»
на тему: «Розробка програмної архітектури, створення та відлагодження програмного коду веб клієнта програмної системи для донорства»






Виконала:                                                                                                     
ст. гр. ПЗПІ-22-2                                                                                              
Моссур Дар'я Євгенівна                                                     
Перевірив:
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович





Харків 2025
?
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін
1	31.05.2025	0.1	Створення структури звіту, визначено завдання та терміни виконання
2	05.06.2025	0.1	Описано мету, хід роботи, зроблено висновки, заповнено додатки до роботи.

2 АНАЛІЗ ЗАВДАННЯ
	В рамках поставленого завдання необхідно реалізувати веб частину програмної системи. Веб частина забезпечує доступ до функціоналу для трьох основних ролей: донора, медичного працівника. Основна мета полягає в створенні інтуїтивно зрозумілого, зручного та адаптивного інтерфейсу, який дозволить користувачам здійснювати дії відповідно до своїх повноважень у системі.
3 ХІД РОБОТИ
	Початковим етапом реалізації веб частини стало проєктування інтерфейсів користувача з урахуванням ролей і доступного функціоналу. Було розроблено структуру навігації, маршрути та компоненти сторінок для різних категорій користувачів. Застосунок створено з використанням сучасних веб-технологій фреймворку React.js для створення клієнтської. Реалізовано модулі автентифікації та авторизації, що забезпечують безпечний доступ до особистих кабінетів. Через REST API налаштовано взаємодію з бекендом: отримання даних про івенти, запис користувача, перегляд історії участі, обробку мовних налаштувань та отримання нотифікацій. Для зручності передбачено перемикання мови інтерфейсу, адаптивність під мобільні пристрої та обробку помилок з боку сервера.

?
	3.1. Архітектура веб частини програмної системи
	Веб-частина програмної системи реалізована як односторінковий застосунок (SPA — Single Page Application), розроблений із використанням бібліотеки React.js. Архітектура побудована за принципами розділення відповідальності, де логіка компонента, бізнес-логіка, API-взаємодія та допоміжні утиліти винесені в окремі модулі. Компонентна модель дозволяє забезпечити гнучкість, масштабованість і повторне використання коду. Було побудовано для чіткої візуалізації, що відображає логічну структуру системи з точки зору компонентів та їх взаємодії (рисунок 3.1).

 
Рисунок 3.1 - UML діаграма компонентів (Component Diagram)

	3.2. Програмні технології та компоненти
	У веб-частині використовуються наступні технології:
	- React.js — як основна бібліотека для побудови інтерфейсу.
	- Axios — для взаємодії з REST API серверної частини.
	- i18next — для локалізації та підтримки декількох мов.
	- React Router — для реалізації маршрутизації між сторінками.
	- Jest — для модульного тестування компонентів.
	- dotenv — для зберігання конфігураційних змінних середовища.
	- Custom Axios Interceptors — для автоматичного додавання токенів авторизації та обробки помилок API.


3.3. Бізнес логіка, доступна у веб частині
	У мобільній частині системи реалізовано підтримку двох основних ролей: донор, медичний працівник. Для мобільного клієнта основний акцент зроблено на зручності використання, інтуїтивному інтерфейсі та забезпеченні повного спектру можливостей для кожної ролі без потреби використання сторонніх інструментів.
	Роль донора орієнтована на забезпечення простого доступу до функціоналу, пов’язаного із участю в подіях донації крові, переглядом історії та керуванням особистим профілем.
	Основний функціонал включає:
	- Перегляд усіх запланованих подій у застосунку — користувач отримує список івентів, де вказано дату, час, місце, заклад, потреби у крові та її тип.
	- Запис на подію здійснюється через інтуїтивний інтерфейс, який надсилає відповідний запит до серверу через API.
	- Перегляд особистих записів — доступний розділ «Мої події», де відображаються всі майбутні й минулі події, на які донор був зареєстрований.
	- Скасування реєстрації — за наявності причин, донор може видалити свій запис до початку заходу.
	Особисті налаштування реалізовані у вигляді окремого розділу, де користувач може:
	- Змінити пароль, скориставшись безпечною формою з клієнтською валідацією.
	- Змінити мову інтерфейсу (доступні українська та англійська).
	- Повністю видалити профіль, у разі чого персональні дані видаляються з бази, а інформація про попередні донації зберігається в анонімізованому вигляді.
	- Переглядати push- або системні нотифікації, які попереджають про заплановані події, зміни або подяки від закладу.
	Роль медичного працівника передбачає значно розширений функціонал, необхідний для щоденного керування донаційною діяльністю. Через мобільний застосунок медик має змогу:
	- Керувати донорами — переглядати список, редагувати інформацію, додавати нових осіб.
	- Додавати інформацію про донацію до системи безпосередньо з мобільного пристрою (наприклад, після завершення процедури забору крові).
	 - Керувати подіями — створювати нові заходи донорства, редагувати їх деталі або видаляти неактуальні.
	 - Переглядати список зареєстрованих донорів на конкретну подію для підготовки.
	 - Керувати холодильниками: реєструвати нові пристрої, переглядати інформацію про наявні, змінювати назву, об’єм або лікарню, а також переглядати історію температурних показників.
	 - Працювати із запасами крові — змінювати їх статус (доступний, зарезервований, використаний, зіпсований тощо), аналізувати наявні одиниці відповідно до їх типу і придатності.
	 - Вносити потреби у крові для свого закладу в актуальному обсязі.
	Вся бізнес-логіка мобільного застосунку реалізована у вигляді Kotlin-компонентів із суворим розділенням відповідальностей за допомогою MVVM-архітектури. Комунікація з бекендом здійснюється через Retrofit з автоматичним додаванням JWT-токену до заголовків запиту за допомогою Interceptor. Клієнтська валідація форм реалізована через LiveData та custom input-валидації. На основі визначеної ролі користувача після входу застосунок динамічно формує доступний набір екранів та дій. Для відображення процесів і логіки роботи мобільного додатку створено Use Case diagrams (рисунок 3.2 - 3.3), діаграму станів (рисунок 3.4), діаграму діяльності (рисунок 3.5). 
 
Рисунок 3.2 – Use Case diagram (Medic)

Рисунок 3.3 – Use Case diagram (Donor)
 
Рисунок 3.4 – UML діаграма станів (State Diagram)
 
Рисунок 3.5 – UML діаграма діяльності (Activity Diagram)
3.4. Захист даних у веб частині програмної системи
У веб частині програмної системи реалізовано комплексний підхід до захисту даних користувачів, що включає авторизацію, автентифікацію, перевірку прав доступу, обробку чутливих даних і забезпечення конфіденційності під час мережевих запитів. Авторизація користувачів здійснюється через JWT-токен, який зберігається у локальному сховищі. Після авторизації користувача, токен додається до заголовків усіх запитів за допомогою Axios Interceptors axiosInstance.js, useAxiosInterceptors.js (код наведений у Додатку А). При кожному HTTP-запиті бекенд перевіряє дійсність токена й відповідно обмежує або дозволяє доступ до певних ресурсів. Права доступу до сторінок визначаються на основі ролі користувача (донор, медик, адміністратор). Для обмеження доступу реалізовані приватні маршрути або перевірка прав у компонентах React. Якщо користувач не має відповідних прав, він перенаправляється на сторінку логіну або отримує відповідне повідомлення про відмову в доступі. 
Процес автентифікації реалізовано через логін-форму (LoginPage.js), яка надсилає запит на /auth/login. У разі успішної автентифікації сервер повертає JWT-токен та перелік ролей користувача. Ці значення зберігаються в localStorage: 
localStorage.setItem(CONSTANTS.TOKEN, response.data.token);
localStorage.setItem(CONSTANTS.ROLES, JSON.stringify(response.data.roles));

Уся взаємодія з сервером здійснюється через налаштований інстанс бібліотеки Axios:
const axiosInstance = axios.create({
  baseURL: CONSTANTS.API_PATH,
});

Повний код наведено у Додатку А. 
Особисті дані користувача (ім’я, пароль тощо) передаються лише у тілі запиту через захищене з’єднання (HTTPS), ніколи не зберігаються у відкритому вигляді у клієнтському коді, пароль передається у вигляді JSON, обробляється лише на сервері. Для забезпечення адаптивності середовища застосунку (розробка, продакшн) та уникнення витоку конфіденційних параметрів, усі конфігурації винесено у .env файл. Це дозволяє мінімізувати ризики витоку URL API, централізовано змінювати оточення. 
Таким чином, веб-клієнт системи забезпечує багаторівневий захист даних користувачів на основі стандартів безпеки сучасних веб-застосунків. Реалізовані механізми відповідають кращим практикам захисту (JWT, HTTPS, централізована обробка токенів, перевірка ролей) і забезпечують надійну роботу з чутливою інформацією.

3.5. Взаємодія веб частини з іншими компонентами системи
Веб клієнт є повноцінною частиною багаторівневої архітектури програмної системи і виконує роль інтерфейсу взаємодії користувача з бізнес-логікою, яка розміщена на серверній стороні. Зв’язок між клієнтом та сервером здійснюється за допомогою RESTful API — архітектурного стилю, що передбачає стандартизовану роботу з ресурсами через HTTP-запити. Такий підхід дозволяє фронтенду незалежно від технологічної реалізації бекенду взаємодіяти з усіма необхідними ресурсами: даними про користувачів, донорами, історією донацій, станом холодильників, потребами у крові тощо.
Усі дані передаються у форматі JSON, що забезпечує компактність, зручність у парсингу та високу сумісність з JavaScript-орієнтованими фреймворками. Для обробки запитів та відповідей використовується бібліотека Axios, яка забезпечує зручний і розширюваний інтерфейс для HTTP-викликів. Axios дозволяє не лише відправляти запити, але й підключати інтерцептори для автоматичної обробки токенів, помилок авторизації та іншої критичної логіки, що значно спрощує масштабування та повторне використання коду.
Цей спосіб взаємодії дозволяє підтримувати реактивність клієнта — усі дії користувача, як-от вхід у систему, оновлення особистих даних або перегляд поточних потреб у крові, відображаються майже миттєво завдяки швидкій обробці відповіді від API. Завдяки цьому клієнтська частина залишається легкою, а ключова бізнес-логіка і перевірки залишаються на сервері, що також сприяє кращій безпеці та масштабованості всієї системи.
 
3.6. Підтримка інтерналізації
Щоб зробити інтерфейс системи доступним для користувачів, що говорять різними мовами, у веб-клієнті реалізовано підтримку інтернаціоналізації. За основу взято бібліотеку i18next — одну з найпопулярніших JavaScript-бібліотек для локалізації, що надає розширені можливості для динамічного перекладу текстів інтерфейсу, з урахуванням мовних та регіональних особливостей.
У рамках реалізації було створено окрему структуру папок, де для кожної підтримуваної мови знаходяться JSON-файли з ключами та відповідними перекладами. Ці файли розміщено в директорії public/locales, а система автоматично підвантажує їх на основі мови браузера користувача. У випадку, коли браузер не підтримує жодну з доступних мов, застосовується мова за замовчуванням (у більшості випадків — українська або англійська).
Усі текстові елементи інтерфейсу — заголовки, підказки, повідомлення про помилки, кнопки — використовують функцію t() із useTranslation, що дозволяє динамічно отримувати відповідні рядки з поточної мовної локалі. Таким чином, зміна мови не потребує перезавантаження сторінки, що позитивно впливає на зручність користування системою. Вибір мови також може бути здійснений вручну — через інтерфейсний компонент, такий як LanguageDropDown.js, який дозволяє користувачу змінити мову інтерфейсу відповідно до власних уподобань.

3.7. Реалізовані варіанти локалізації
	На момент розробки система підтримує щонайменше дві мовні локалі: українську та англійську, хоча структура реалізації дозволяє легко додати нові мови в майбутньому. Для кожної мови створено окрему директорію у файловій системі, де міститься набір JSON-файлів із перекладами. Кожен файл містить перелік ключів та значень, які відповідають конкретним текстовим елементам інтерфейсу, таким як назви сторінок, поля форм, системні повідомлення та інші. Користувач може змінювати мову інтерфейсу без необхідності оновлювати сторінку, оскільки бібліотека i18next підтримує гаряче перемикання мовної локалі з оновленням усіх компонентів у реальному часі. Це дозволяє кожному користувачу обирати найбільш зручну мову взаємодії та робить систему доступною для ширшої аудиторії, включно з потенційними донорами, лікарями та адміністративним персоналом, які можуть володіти різними мовами. 

3.8. Функціональність для налаштування та адміністрування 
Веб клієнт надає можливість не лише для перегляду інформації, а й для повноцінного керування ключовими складовими системи, що особливо важливо для медичних працівників. Після проходження автентифікації користувач з відповідною роллю отримує доступ до інтерфейсу, що дозволяє керувати ресурсами системи у відповідності до їхніх функціональних повноважень. Інтерфейс адміністрування включає модулі для створення, оновлення та перегляду інформації про лікарні, події донорства, холодильники з кров’ю, користувачів системи та інші критичні об’єкти. Медичні працівники можуть оперативно оновлювати інформацію про стан холодильників, вносити нові донації до бази, або реєструвати нових донорів. Вся ця інформація відображається у режимі реального часу завдяки реактивності фронтенду та швидкому обміну даними з бекендом через API. Функціональність керування даними реалізована з урахуванням ролей користувачів, які визначаються ще під час логіну. Це означає, що користувачі без відповідних прав не зможуть навіть побачити або взаємодіяти з елементами, призначеними для адміністрації. Такий підхід дозволяє ефективно реалізувати контроль доступу на клієнтському рівні та захистити систему від помилкових або несанкціонованих дій.
Весь адміністративний функціонал є частиною загальної концепції централізованого управління системою, що дозволяє медичним закладам адаптувати платформу під свої потреби, підтримуючи актуальність усіх даних без необхідності втручання розробників або операторів зовнішніх систем.

?
ВИСНОВКИ
	У результаті розробки було реалізовано повноцінний веб клієнт для інформаційної системи, що забезпечує ефективну взаємодію з серверною частиною через RESTful API. Завдяки використанню сучасних технологій, таких як React, вдалося створити зручний, адаптивний і локалізований інтерфейс, який підтримує авторизацію, розмежування прав доступу та динамічне оновлення даних.
	Реалізація інтернаціоналізації забезпечує зручність використання системи для користувачів з різною мовною належністю, а рольова модель доступу дозволяє точно налаштувати функціональність для кожної категорії користувачів. Гнучка архітектура та модульність коду спрощують подальше масштабування й підтримку проєкту, а також дозволяють безболісно розширювати функціонал у майбутньому.
	Загалом, створений клієнт є надійною, масштабованою та доступною платформою для підтримки процесів донорства та медичної логістики.

ДОДАТОК А

Посилання на відео: https://youtu.be/yrj2ar8asxE?

ДОДАТОК Б
Код програмної реалізації веб частини

axiosInstance.js:
import axios from 'axios';
import CONSTANTS from './Constants';
const axiosInstance = axios.create({
  baseURL: CONSTANTS.API_PATH,
});

export default axiosInstance;

	useAxiosInterceptors.js

import { useEffect } from 'react';
import axiosInstance from './axiosInstance';
import CONSTANTS from './Constants';
import { handleLogout } from './logout';

export const useAxiosInterceptors = (navigate) => {
    useEffect(() => {
      const requestInterceptor = axiosInstance.interceptors.request.use(
        (config) => {
          const token = localStorage.getItem(CONSTANTS.TOKEN);
          if (token) {
            config.headers['Authorization'] = 'Bearer ' + token;
          }
          //config.headers['Access-Control-Allow-Origin'] = '*';
          //config.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT';
          //config.headers['Access-Control-Allow-Headers'] = 'Content-Type';
          return config;
        },
        (error) => {
          return Promise.reject(error);
        }
      );
  
      const responseInterceptor = axiosInstance.interceptors.response.use(
        (response) => response,
        (error) => {
          if (error.response && (error.response.status === 401)) {
            handleLogout(navigate);
          }
          return Promise.reject(error);
        }
      );
  
      return () => {
        axiosInstance.interceptors.request.eject(requestInterceptor);
        axiosInstance.interceptors.response.eject(responseInterceptor);
      };
    }, [navigate]);
  }
	LoginPage.js

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import CONSTANTS from '../misc/Constants';
import axiosInstance from '../misc/axiosInstance';
import { useTranslation } from 'react-i18next';

const LoginPage = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const { t } = useTranslation();

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      const payload = {
          username: username,
          password: password,
          };
      const response = await axiosInstance.post(CONSTANTS.API_PATH + '/auth/login', payload, { 
        headers: {
            'Content-Type': 'application/json',
          }
      });
      if (response.status === 200) {
        localStorage.setItem(CONSTANTS.TOKEN, response.data.token);
        localStorage.setItem(CONSTANTS.ROLES, JSON.stringify(response.data.roles));
        localStorage.setItem(CONSTANTS.PI_AGREED, response.data.piAgreed);
        navigate('/home');
      }
    } catch (err) {
      setError(t("login_failed"));
    }
  };

  useEffect(() => {
    if (localStorage.getItem(CONSTANTS.TOKEN)) {
      navigate("/home");
    }
  });

  return (
    <div className="py-23 flex justify-center items-center min-h-screen bg-white">
      <div className="w-full max-w-md p-6 bg-white shadow-lg rounded-lg">
        <h2 className="text-4xl font-bold text-black mb-6">{t("welcome")}</h2>
        {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
        
        <form onSubmit={handleLogin} className="space-y-4">
          <div>
            <label className="block text-black font-medium mb-2">{t("username_label")}</label>
            <input 
              type="text" 
              value={username} 
              onChange={(e) => setUsername(e.target.value)} 
              className="w-full p-3 border-2 border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-red-400"
            />
          </div>
          
          <div>
            <label className="block text-black font-medium mb-2">{t("password_label")}</label>
            <input 
              type="password" 
              value={password} 
              onChange={(e) => setPassword(e.target.value)} 
              className="w-full p-3 border-2 border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-red-400"
            />
          </div>
          
          <button 
            type="submit" 
            className="w-full py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-400"
          >
            {t("login_button_label")}
          </button>
        </form>
      </div>
    </div>
  );
};


	App.js

export default LoginPage;	
import React from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate } from 'react-router-dom';
import LoginPage from './pages/LoginPage';
import HomePage from './pages/HomePage';
import BloodNeedsPage from './pages/BloodNeedsPage';
import CreateDonorPage from './pages/CreateDonorPage';
import CreateEventPage from './pages/CreateEventPage';
import CreateFridgePage from './pages/CreateFridgePage';
import CreateDonationPage from './pages/CreateDonationPage';
import BloodSupplyPage from './pages/BloodSupplyPage';
import EditBloodPage from './pages/EditBloodPage';
import AllFridgesPage from './pages/AllFridgesPage';
import FridgeMetricsPage from './pages/FridgeMetricsPage';
import Header from './components/Header';
import useLocalizeDocumentAttributes from './misc/useLocalizeDocumentAttributes';
import './tailwind.css';

const App = () => {
  useLocalizeDocumentAttributes();

  return (
    <Router>
      <Header/>
      <Routes>
        <Route path="/" element={<LoginPage />} />
        <Route path="/home" element={<HomePage />} />
        <Route path="/blood-needs" element={<BloodNeedsPage />} />
        <Route path="/create-donor" element={<CreateDonorPage />} />
        <Route path="/create-event" element={<CreateEventPage />} />
        <Route path="/create-fridge" element={<CreateFridgePage />} />
        <Route path="/create-donation" element={<CreateDonationPage />} />
        <Route path='/blood-supply' element={<BloodSupplyPage />} />
        <Route path='/edit-blood/:id' element={<EditBloodPage />} />
        <Route path='/all-fridges' element={<AllFridgesPage />} />
        <Route path='/fridge-metrics/:id' element={<FridgeMetricsPage />} />
        <Route path="*" element={<Navigate to="/home" replace />} />
      </Routes>
    </Router>
  );
};

export default App;